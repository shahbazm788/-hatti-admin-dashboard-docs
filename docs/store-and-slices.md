
---

# üß† State Management (Zustand)

Hatti utilizes **Zustand** for global state management. This provides a lightweight, flexible, and high-performance alternative to Redux. By using atomic state updates and a **Slice-Based Architecture**, domain logic remains separated but unified in a single, accessible store.

---

## üèóÔ∏è 1. Store Architecture

The store is designed using the **Merged Slice Pattern**. Instead of multiple disconnected stores, Hatti uses a single store instance where different "creators" define specific state domains (Auth, Products, Chat, etc.).

### **Implementation**

The unified store engine merges multiple domain-specific slices into a single `RootStore`.

```tsx
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

export const useStore = create<RootStore>()(
  devtools((set, get, store) => ({
    ...createAuthSlice(set, get),
    ...createProductSlice(set, get),
    ...createOrderSlice(set, get),
    ...createChatSlice(set, get),
    // Additional slices...
  }))
);

```

---

## üß© 2. Domain Slices

Each slice manages a specific functional area. This modularity ensures that authentication logic does not interfere with product management or real-time features.

| Slice | Primary Responsibility | Key State/Actions |
| --- | --- | --- |
| **`AuthSlice`** | Session & Permissions | `user`, `login()`, `logout()` |
| **`ProductSlice`** | Inventory Management | `products`, `fetchProducts()`, `deleteProduct()` |
| **`OrderSlice`** | Sales & Transactions | `orders`, `updateStatus()`, `revenue` |
| **`ChatSlice`** | Real-time Messaging | `messages`, `activeUser`, `sendMessage()` |
| **`KanbanSlice`** | Project Management | `boards`, `cards`, `moveCard()` |
| **`CalendarSlice`** | Scheduling | `events`, `addEvent()`, `viewMode` |

---

## ‚ö° 3. Optimized Hooks & Subscriptions

To prevent unnecessary re-renders, Hatti provides **Domain-Specific Wrappers**. These hooks allow for selective state subscription, ensuring your components only update when the relevant data changes.

### **Subscription Patterns**

#### **A. Selective Access (Recommended)**

Grabs only specific properties. This is highly optimized for performance-critical components like large tables or charts.

```tsx
// Only re-renders when 'products' changes
const products = useProductStore(state => state.products);
const addProduct = useProductStore(state => state.addProduct);

```

#### **B. Full State Access**

Grabs everything in that domain. Useful for simpler components where performance isn't a bottleneck.

```tsx
const { products, deleteProduct, loading } = useProductStore();

```

---

## üõ†Ô∏è 4. Professional Debugging

The store is pre-configured with **Redux DevTools Middleware**. This allows developers to:

* **Inspect** every state change in real-time.
* **Time Travel** by jumping back to previous states.
* **Debug** complex flows with professional-grade tooling.

---

## üí° 5. Best Practices for Developers

* **Selector Usage:** Always use selectors (Selective Access) in UI-heavy components to maintain 60 FPS performance.
* **Action Placement:** Keep business logic inside the slice creators (actions) rather than in components. This keeps the UI layer "thin" and focused on rendering.
* **Type Safety:** The `RootStore` type is automatically generated by merging slice interfaces, ensuring full TypeScript support (IntelliSense) across the entire application.

---

